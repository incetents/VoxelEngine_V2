
#Name { gbuffer }

#Attributes
{
	vec3 m_position 	: 0
	vec2 m_uv 			: 1
	vec3 m_normal 		: 2
	vec3 m_tangent 		: 6
	mat4 instanceMatrix : 8
}

#Include
{
	_UBO.glsl,
	_Uniforms.glsl
}

#Samplers
{
	// Uniform Textures
	sampler2D albedo_handler : 0
}

#Properties
{
	// No uniforms here
}

#Vertex
{
	// Output
	out vertex_data
	{
		vec3 pos;
		vec2 uv;
		vec3 normal;
		vec3 tangent;
		vec3 bitangent;

	} v_data;

	// Main
	void main()
	{
		// Model
		if(VXL_useModel)
		{
			mat4 model = VXL_model;
			
			// Instance matrix occurs before model matrix (if applicable)
			if(VXL_useInstancing)
				model *= instanceMatrix;

			// Position
			v_data.pos = vec3(model * vec4(m_position, 1.0));
			// Normals
			v_data.normal = VXL_normalMatrix * m_normal;
			v_data.tangent = VXL_normalMatrix * m_tangent;
		}
		// Passthrough
		else
		{
			// Position
			v_data.pos = m_position;
			// Normal
			v_data.normal = m_normal;
			v_data.tangent = m_tangent;
		}
		
		gl_Position = UBO_viewProjection * vec4(v_data.pos, 1); 
		
		// Constants
		v_data.uv = m_uv;
		v_data.bitangent = cross(v_data.normal, v_data.tangent);
	}
}

#Fragment
{
	// Input
	in vertex_data
	{
		vec3 pos;
		vec2 uv;
		vec3 normal;
		vec3 tangent;
		vec3 bitangent;

	} v_data;

	// Output
	layout (location = 0) out vec4 output_albedo;
	layout (location = 1) out vec4 output_normal;
	layout (location = 2) out vec4 output_reflection;
	layout (location = 3) out vec4 output_colorID;

	//Main
	void main()
	{
		output_albedo = vec4(0,0,0,VXL_alpha);
	
		if(VXL_useTexture)
		{
			output_albedo.rgb = texture(albedo_handler, v_data.uv).rgb;
		}
	
		output_albedo.rgb = output_albedo.rgb * VXL_tint + VXL_color;
			
		output_normal = vec4(normalize(v_data.normal), 1); // worldspace Normals

		output_reflection = vec4(0,0,0,1);
		output_colorID = VXL_output;
	}
}
